/*
a=10
b=20
위와 같은 파이썬 코드에서 a,b는 객체 10,20에 어떤 방식으로 매핑되는가?
a,b 등 변수 이름을 따로 묶어서 저장하고
10,20 등 객체들도 따로 묶어서 저장한다.

PyCodeObject
저장 위치:힙
저장 값:변수의 이름
저장 형식:배열

PyFrameObject
저장 위치:힙
저장 값:객체의 값
저장 형식:

컴파일 타임:
파이썬 코드에서 변수가 등장하는 순서대로 PyCodeObject를 생성함. 
이름 "a" "b"를 만들기 위해 pycodeobject를 힙에 malloc으로 생성함. 
지역변수를 co_varname, 전역변수는 co_name에 저장함. 

co_varname이 포인터로서 "a"를 참조한다는 것을 알 수 있음. 
그러나 그 a가 어떤 객체를 참조하는지 주소는 pycodeobject에 저장하지 않음.
PyCodeObject는  다음과 같은 정보가 들어간다.
"어떤 이름이 등장하는지"
"그 이름이 몇 번째 인덱스인지"
"어떤 바이트코드 명령어가 실행되어야 하는지"

런타임:
PyFrameObject 객체를 생성함. 
이 객체 자체를 스택 프레임이라고 함.

함수 종료 시:
함수가 끝나거나 (return, exception) 하면
→ PyFrameObject 자체가 파괴(free) 된다.
f_localsplus 안에 있던 값들도 관리 해제.
프레임과 함께 "이름 → 값" 매칭이 깨진다.
오직 PyCodeObject만 남는다.
그런데 이 PyCodeObject는 "이름"만 알고 "값"은 모르니까, 함수 실행이 끝난 뒤에는 변수의 값은 복구할 수 없다.

런타임에 변수에 값을 할당할 때:
어떤 변수가 co_varnames[n]에 위치하면 f_localsplus[n]에 객체의 주소를 할당한다.
변수 할당 시마다 co_varnames 배열에서 변수 이름을 찾아야 하기 때문에,
 그 과정에서 시간복잡도 O(n)이 걸림. co_varnames 배열의 크기(n)만큼 순차적으로 검색을 하게됨.
예를들어 co_varnames에 "a","b","c","d" 가 있고, 파이썬에서 c=3을 실행하면
기존의 co_varnames에 c가 있는지 확인하여 3번째 위치에 있으므로
f_localsplus[2]=int 3 객체의 주소 를 넣는다.


함수 실행이 끝나고 인터프리터는 해당 스코프의 모든 지역변수 객체들에 대해 참조카운트를


키워드:
Py_DECREF를 실행하는 주체, 인터프리터, 가비지 컬렉션 메커니즘, Python의 스택 프레임 관리 시스템

a = 2라는 지역 변수가 있을 때, f() 함수가 종료되면 해당 변수 a에 대한 참조 카운트가 감소되고, a가 참조하는 객체가 더 이상 다른 곳에서 참조되지 않으면 메모리에서 해제
*/



