<div>
  <h2>퀵 정렬 성능 비교 보고서 초안</h2>

  <h3>개요:</h3>
  <p>I. 퀵 정렬을 구현하는 3가지 방법</p>
  <ul>
    <li>in-place:
      <ul>
        <li>호어 방법 / 메모리 추가 사용 x</li>
        <li>로무토 방법 / 메모리 추가 사용 x</li>
      </ul>
    </li>
    <li>not in-place:
      <ul>
        <li>그 외의 방법 / 메모리 추가 사용 o</li>
      </ul>
    </li>
  </ul>

  <p>II. 퀵 정렬의 성능을 높이는 방법</p>
  <ul>
    <li>3-median 방법</li>
    <li>dual pivot</li>
    <li>3분할 방법</li>
  </ul>

  <h3>본론:</h3>
  <ul>
    <li>I. 호어, 로무토 방법의 시간 측정</li>
    <li>II. 확률 기댓값 기반 3-median의 성능 분석</li>
    <li>III. dual pivot의 시간복잡도 k×log₃(n) 분석</li>
  </ul>
</div>


#재귀 구조
array=input()

def swap(a,b):
    array[a],array[b]=array[b],array[a]

def partition(start,end):
    pass

def quicksort(start,end,partition):
    pivot=partition(start,end)
    quicksort(start,pivot-1)
    quicksort(pivot+1,end)


quicksort(0,len(array)-1,hoare_asc)
quicksort(0,len(array)-1,hoare_desc)


#호어 방법 - 오름차순
def hoare_asc(start,end):
    left=start
    right=end
    pivot=start 
    while True:
        while array[left]<=array[pivot]:
            left+=1
        while array[right]>=array[pivot]:
            right-=1
        if left>=right:
            break
        swap(left,right)
    if array[pivot]>array[right]:
        swap(right,pivot)
    return right

#호어 방법 - 내림차순
def hoare_desc(start,end):
    left=start
    right=end 
    pivot=end     
    while True:
        while array[left]>=array[pivot] and left<right:
            left+=1
        while array[right]<=array[pivot] and left<right:
            right-=1
        if left>=right:
            break
        swap(left,right)
    if array[pivot]>array[left]: #이쪽도 변경해줌. 위쪽 변경안하고
        swap(left,pivot)
    return left